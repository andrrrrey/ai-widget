diff --git a/server/sql/004_project_telegram_chats.sql b/server/sql/004_project_telegram_chats.sql
new file mode 100644
index 0000000000000000000000000000000000000000..8b7130114b3dade6cb77b2b0f34c51e54d859ce3
--- /dev/null
+++ b/server/sql/004_project_telegram_chats.sql
@@ -0,0 +1,14 @@
+-- 004_project_telegram_chats.sql — multiple telegram chats per project
+
+CREATE TABLE IF NOT EXISTS project_telegram_chats (
+  project_id text NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
+  chat_id text NOT NULL,
+  chat_type text NULL,
+  created_at timestamptz NOT NULL DEFAULT NOW(),
+  PRIMARY KEY (project_id, chat_id)
+);
+
+CREATE INDEX IF NOT EXISTS project_telegram_chats_chat_idx ON project_telegram_chats(chat_id);
+
+ALTER TABLE telegram_link_tokens
+  ADD COLUMN IF NOT EXISTS chat_type text NULL;
diff --git a/server/src/index.js b/server/src/index.js
index 4f4364fd7a8c768ea292bd330bc13523792bebe6..27734f8fc6b91a8103b6833f2fa9d37d2f9fe90d 100644
--- a/server/src/index.js
+++ b/server/src/index.js
@@ -1,44 +1,46 @@
 import express from "express";
 import cookieParser from "cookie-parser";
 import path from "path";
 import { fileURLToPath } from "url";
 import dotenv from "dotenv";
 
 import { ensureSchema, pool } from "./lib/db.js";
 import { requireAdmin, requireUser, loginHandler, logoutHandler, hashPassword } from "./lib/auth.js";
 import {
   createUser,
   listUsers,
   updateUserPassword,
   deleteUser,
   findUserByEmail,
   createProject,
   listProjects,
   getProject,
   updateProject,
   deleteProject,
+  addProjectTelegramChat,
+  deleteProjectTelegramChats,
   createChat,
   getChatById,
   listChats,
   listMessages,
   addMessage,
   setChatMode,
   touchChat,
   countUserMessages,
 } from "./lib/store.js";
 import { widgetCors } from "./lib/widgetCors.js";
 import {
   fetchAssistantInstructions,
   runAssistantStream,
   syncOperatorToThread,
   updateAssistantInstructions,
 } from "./lib/openai.js";
 import { getChatDisplayName } from "./lib/chatNames.js";
 import {
   consumeTelegramSecret,
   notifyProjectAboutFirstMessage,
   notifyProjectAboutContacts,
   extractContactInfo,
 } from "./lib/telegram.js";
 
 dotenv.config({ path: "/var/www/ai-widget/server/.env" });
@@ -303,56 +305,66 @@ app.post("/api/user/projects", requireUser, async (req, res) => {
 app.get("/api/user/projects/:projectId", requireUser, async (req, res) => {
   const project = await getProject(req.params.projectId);
   if (!project || project.owner_id !== req.auth.userId)
     return res.status(404).json({ error: "project_not_found" });
   res.json({ project });
 });
 
 app.patch("/api/user/projects/:projectId", requireUser, async (req, res) => {
   const project = await getProject(req.params.projectId);
   if (!project || project.owner_id !== req.auth.userId)
     return res.status(404).json({ error: "project_not_found" });
 
   const patch = {};
 
   if (typeof req.body?.name === "string") patch.name = req.body.name;
   if (typeof req.body?.assistant_id === "string") patch.assistant_id = req.body.assistant_id;
   if (typeof req.body?.openai_api_key === "string") patch.openai_api_key = req.body.openai_api_key;
   if (typeof req.body?.instructions === "string") patch.instructions = req.body.instructions;
   if (Array.isArray(req.body?.allowed_origins)) patch.allowed_origins = req.body.allowed_origins.map(String);
 
   if (typeof req.body?.telegram_code === "string") {
     const code = req.body.telegram_code.trim();
     if (code) {
       const token = await consumeTelegramSecret(code);
       if (!token) return res.status(400).json({ error: "invalid_telegram_code" });
-      patch.telegram_chat_id = token.chat_id;
-      patch.telegram_connected_at = new Date();
+      await addProjectTelegramChat({
+        projectId: project.id,
+        chatId: token.chat_id,
+        chatType: token.chat_type,
+      });
+      if (!project.telegram_chat_id) {
+        patch.telegram_chat_id = token.chat_id;
+      }
+      if (!project.telegram_connected_at) {
+        patch.telegram_connected_at = new Date();
+      }
     }
   }
 
   if (req.body?.unlink_telegram === true) {
+    await deleteProjectTelegramChats(project.id);
     patch.telegram_chat_id = null;
     patch.telegram_connected_at = null;
   }
 
   const updated = await updateProject(req.params.projectId, patch);
   res.json({ project: updated });
 });
 
 app.delete("/api/user/projects/:projectId", requireUser, async (req, res) => {
   const project = await getProject(req.params.projectId);
   if (!project || project.owner_id !== req.auth.userId)
     return res.status(404).json({ error: "project_not_found" });
   await deleteProject(req.params.projectId);
   res.json({ ok: true });
 });
 
 app.get("/api/admin/projects/:projectId", requireAdmin, async (req, res) => {
   const project = await getProject(req.params.projectId);
   if (!project) return res.status(404).json({ error: "project_not_found" });
   res.json({ project });
 });
 
 app.get(
   "/api/admin/projects/:projectId/assistant-instructions",
   requireAdmin,
@@ -400,56 +412,66 @@ app.get(
 );
 
 app.patch("/api/admin/projects/:projectId", requireAdmin, async (req, res) => {
   const current = await getProject(req.params.projectId);
   if (!current) return res.status(404).json({ error: "project_not_found" });
   
   const patch = {};
 
   if (typeof req.body?.name === "string") patch.name = req.body.name;
   if (typeof req.body?.assistant_id === "string") patch.assistant_id = req.body.assistant_id;
 
   // ✅ ВОТ ЭТА СТРОКА РЕШАЕТ ПРОБЛЕМУ: позволяет сохранять API key при PATCH
   if (typeof req.body?.openai_api_key === "string") patch.openai_api_key = req.body.openai_api_key;
 
   if (typeof req.body?.instructions === "string") patch.instructions = req.body.instructions;
   if (Array.isArray(req.body?.allowed_origins)) patch.allowed_origins = req.body.allowed_origins.map(String);
   if (Object.hasOwn(req.body || {}, "owner_id")) {
     patch.owner_id = typeof req.body.owner_id === "string" && req.body.owner_id ? req.body.owner_id : null;
   }
 
   if (typeof req.body?.telegram_code === "string") {
     const code = req.body.telegram_code.trim();
     if (code) {
       const token = await consumeTelegramSecret(code);
       if (!token) return res.status(400).json({ error: "invalid_telegram_code" });
-      patch.telegram_chat_id = token.chat_id;
-      patch.telegram_connected_at = new Date();
+      await addProjectTelegramChat({
+        projectId: current.id,
+        chatId: token.chat_id,
+        chatType: token.chat_type,
+      });
+      if (!current.telegram_chat_id) {
+        patch.telegram_chat_id = token.chat_id;
+      }
+      if (!current.telegram_connected_at) {
+        patch.telegram_connected_at = new Date();
+      }
     }
   }
 
   if (req.body?.unlink_telegram === true) {
+    await deleteProjectTelegramChats(current.id);
     patch.telegram_chat_id = null;
     patch.telegram_connected_at = null;
   }
 
   const project = await updateProject(req.params.projectId, patch);
   if (!project) return res.status(404).json({ error: "project_not_found" });
   
   const assistantId = patch.assistant_id ?? current.assistant_id;
   const apiKey = patch.openai_api_key ?? current.openai_api_key;
   const instructions = patch.instructions ?? current.instructions;
 
   if (
     typeof req.body?.instructions === "string" &&
     assistantId &&
     apiKey &&
     isLikelyAssistantId(assistantId)
   ) {
     try {
       await updateAssistantInstructions({ apiKey, assistantId, instructions });
     } catch (err) {
       console.warn("assistant instructions update failed", err?.message || err);
       return res
         .status(500)
         .json({ error: "failed_to_update_assistant", message: err?.message || "" });
     }
diff --git a/server/src/lib/store.js b/server/src/lib/store.js
index 953b1af9383cc2f93279165125e06f1b408f365d..d170defb2beb465eb880fd7ff733ad233583c320 100644
--- a/server/src/lib/store.js
+++ b/server/src/lib/store.js
@@ -85,50 +85,76 @@ export async function updateProject(projectId, patch) {
   const telegramChatId = Object.hasOwn(patch, "telegram_chat_id")
     ? patch.telegram_chat_id
     : p.telegram_chat_id;
   const telegramConnectedAt = Object.hasOwn(patch, "telegram_connected_at")
     ? patch.telegram_connected_at
     : p.telegram_connected_at;
 
   return await sql.one(
     `UPDATE projects
      SET name=$2, assistant_id=$3, openai_api_key=$4, instructions=$5, allowed_origins=$6, owner_id=$7, telegram_chat_id=$8, telegram_connected_at=$9, updated_at=NOW()
      WHERE id=$1 RETURNING *`,
     [
       projectId,
       name,
       assistantId,
       openaiApiKey,
       instructions,
       allowedOrigins,
       ownerId,
       telegramChatId,
       telegramConnectedAt,
     ]
   );
 }
 
+export async function addProjectTelegramChat({ projectId, chatId, chatType = null }) {
+  if (!projectId || !chatId) return false;
+  await sql.exec(
+    `INSERT INTO project_telegram_chats (project_id, chat_id, chat_type)
+     VALUES ($1,$2,$3)
+     ON CONFLICT (project_id, chat_id)
+     DO UPDATE SET chat_type=EXCLUDED.chat_type`,
+    [projectId, String(chatId), chatType || null]
+  );
+  return true;
+}
+
+export async function listProjectTelegramChats(projectId) {
+  if (!projectId) return [];
+  return await sql.many(
+    "SELECT chat_id, chat_type, created_at FROM project_telegram_chats WHERE project_id=$1 ORDER BY created_at ASC",
+    [projectId]
+  );
+}
+
+export async function deleteProjectTelegramChats(projectId) {
+  if (!projectId) return false;
+  await sql.exec("DELETE FROM project_telegram_chats WHERE project_id=$1", [projectId]);
+  return true;
+}
+
 export async function deleteProject(projectId) {
   const existing = await getProject(projectId);
   if (!existing) return false;
   await sql.exec("DELETE FROM projects WHERE id=$1", [projectId]);
   return true;
 }
 
 export async function createChat({ projectId, visitorId, openaiApiKey }) {
   const threadId = await ensureThread(openaiApiKey);
   const id = uuidv4();
 
   const row = await sql.one(
     `INSERT INTO chats (id, project_id, thread_id, mode, status, visitor_id)
      VALUES ($1,$2,$3,'assistant','open',$4) RETURNING *`,
     [id, projectId, threadId, visitorId || null]
   );
   return row;
 }
 
 export async function getChatById(chatId) {
   return await sql.oneOrNone("SELECT * FROM chats WHERE id=$1", [chatId]);
 }
 
 export async function listChats({ projectId, status = null, mode = null }) {
   const where = ["project_id=$1"];
diff --git a/server/src/lib/telegram.js b/server/src/lib/telegram.js
index a94aa2b0791301dcc85b780f0519d8fedd41df96..e8dfeecfbb50377fbc3e3b7c74caf8e34f7b2a41 100644
--- a/server/src/lib/telegram.js
+++ b/server/src/lib/telegram.js
@@ -1,149 +1,170 @@
 import dotenv from "dotenv";
 dotenv.config({ path: "/var/www/ai-widget/server/.env" });
 
 import crypto from "crypto";
 
 import { sql } from "./db.js";
+import { getChatDisplayName } from "./chatNames.js";
+import { listProjectTelegramChats } from "./store.js";
 
 const TELEGRAM_TOKEN = process.env.TELEGRAM_BOT_TOKEN || "";
 
 function randomSecret() {
   return crypto.randomBytes(5).toString("hex");
 }
 
 export function isTelegramConfigured() {
   return Boolean(TELEGRAM_TOKEN);
 }
 
-export async function issueTelegramSecret({ chatId, username = null }) {
+export async function issueTelegramSecret({ chatId, username = null, chatType = null }) {
   if (!chatId) throw new Error("chat_id_required");
 
   let attempts = 0;
   while (attempts < 5) {
     const secret = randomSecret();
     try {
       await sql.exec(
-        `INSERT INTO telegram_link_tokens (secret, chat_id, username)
-         VALUES ($1,$2,$3)`,
-        [secret, String(chatId), username || null]
+        `INSERT INTO telegram_link_tokens (secret, chat_id, username, chat_type)
+         VALUES ($1,$2,$3,$4)`,
+        [secret, String(chatId), username || null, chatType || null]
       );
       return secret;
     } catch (err) {
       // retry on conflict
       attempts += 1;
       if (attempts >= 5) throw err;
     }
   }
   throw new Error("failed_to_generate_secret");
 }
 
 export async function consumeTelegramSecret(secret) {
   if (!secret) return null;
   return await sql.oneOrNone(
     `UPDATE telegram_link_tokens
        SET used_at=NOW()
      WHERE secret=$1 AND used_at IS NULL
-     RETURNING chat_id, username, created_at`,
+     RETURNING chat_id, username, chat_type, created_at`,
     [secret]
   );
 }
 
 export async function sendTelegramMessage(chatId, text) {
   if (!TELEGRAM_TOKEN || !chatId || !text) return false;
 
   const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
   const body = { chat_id: chatId, text };
   const r = await fetch(url, {
     method: "POST",
     headers: { "Content-Type": "application/json" },
     body: JSON.stringify(body),
   });
 
   if (!r.ok) {
     const payload = await r.text();
     throw new Error(`telegram_error_${r.status}: ${payload}`);
   }
   return true;
 }
 
 function formatProjectTitle(project) {
   return project?.name ? `"${project.name}"` : "вашем сайте";
 }
 
 function formatChatId(chat) {
-  return chat?.id || "неизвестен";
+  if (!chat?.id) return "неизвестен";
+  return getChatDisplayName(chat.id);
+}
+
+async function listProjectTelegramChatIds(project) {
+  if (!project?.id) return [];
+  const rows = await listProjectTelegramChats(project.id);
+  const ids = rows.map((row) => row.chat_id).filter(Boolean);
+  if (project.telegram_chat_id && !ids.includes(project.telegram_chat_id)) {
+    ids.push(project.telegram_chat_id);
+  }
+  return ids;
 }
 
 function normalizeMatch(value) {
   return String(value || "").trim();
 }
 
 export function extractContactInfo(text) {
   if (!text) return [];
   const candidates = [];
   const emailMatches = text.match(/\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi) || [];
   emailMatches.forEach((value) => candidates.push({ type: "email", value }));
 
   const phoneMatches = text.match(/(\+?\d[\d\s().-]{6,}\d)/g) || [];
   phoneMatches.forEach((value) => candidates.push({ type: "phone", value }));
 
   const tgHandleMatches = text.match(/(?:^|\s)@([a-zA-Z0-9_]{5,})/g) || [];
   tgHandleMatches.forEach((value) => candidates.push({ type: "telegram", value }));
 
   const tmeMatches = text.match(/t\.me\/([a-zA-Z0-9_]+)/gi) || [];
   tmeMatches.forEach((value) => candidates.push({ type: "telegram", value }));
 
   const waMatches = text.match(/wa\.me\/\d+/gi) || [];
   waMatches.forEach((value) => candidates.push({ type: "whatsapp", value }));
 
   const tgLabelMatches = text.match(/(?:телеграм|telegram|tg)[:\s]+([\w@.+-]{3,})/gi) || [];
   tgLabelMatches.forEach((value) => candidates.push({ type: "telegram", value }));
 
   const waLabelMatches = text.match(/(?:whatsapp|ватсап|ватап)[:\s]+([\w@.+-]{3,})/gi) || [];
   waLabelMatches.forEach((value) => candidates.push({ type: "whatsapp", value }));
 
   const unique = new Map();
   candidates.forEach((item) => {
     const cleaned = normalizeMatch(item.value);
     if (!cleaned) return;
     const key = `${item.type}:${cleaned.toLowerCase()}`;
     if (!unique.has(key)) {
       unique.set(key, { type: item.type, value: cleaned });
     }
   });
 
   return Array.from(unique.values());
 }
 
 export async function notifyProjectAboutFirstMessage(project, chat, messageText) {
-  if (!project?.telegram_chat_id || !isTelegramConfigured()) return;
+  if (!isTelegramConfigured()) return;
   const title = formatProjectTitle(project);
+  const chatIds = await listProjectTelegramChatIds(project);
+  if (chatIds.length === 0) return;
   const message =
     `На проекте ${title} получено первое сообщение от пользователя.\n` +
     `ID чата: ${formatChatId(chat)}.\n` +
     `Сообщение: ${String(messageText || "").trim().slice(0, 500) || "—"}`;
 
-  try {
-    await sendTelegramMessage(project.telegram_chat_id, message);
-  } catch (err) {
-    console.warn("telegram notify failed", err?.message || err);
+  for (const chatId of chatIds) {
+    try {
+      await sendTelegramMessage(chatId, message);
+    } catch (err) {
+      console.warn("telegram notify failed", err?.message || err);
+    }
   }
 }
 
 export async function notifyProjectAboutContacts(project, chat, contacts, messageText) {
-  if (!project?.telegram_chat_id || !isTelegramConfigured()) return;
+  if (!isTelegramConfigured()) return;
   if (!Array.isArray(contacts) || contacts.length === 0) return;
   const title = formatProjectTitle(project);
+  const chatIds = await listProjectTelegramChatIds(project);
+  if (chatIds.length === 0) return;
   const contactsLine = contacts.map((item) => item.value).join(", ");
   const message =
     `На проекте ${title} пользователь оставил контакты.\n` +
     `ID чата: ${formatChatId(chat)}.\n` +
     `Контакты: ${contactsLine}\n` +
     `Сообщение: ${String(messageText || "").trim().slice(0, 500) || "—"}`;
 
-  try {
-    await sendTelegramMessage(project.telegram_chat_id, message);
-  } catch (err) {
-    console.warn("telegram notify failed", err?.message || err);
+  for (const chatId of chatIds) {
+    try {
+      await sendTelegramMessage(chatId, message);
+    } catch (err) {
+      console.warn("telegram notify failed", err?.message || err);
+    }
   }
 }
diff --git a/server/src/telegram-bot.js b/server/src/telegram-bot.js
index 3525fce1e750760d2e2c150b803eab2d923f6e6b..a49230a0cb6a4c908520153adddfdfacb8e3b65d 100644
--- a/server/src/telegram-bot.js
+++ b/server/src/telegram-bot.js
@@ -2,50 +2,51 @@ import dotenv from "dotenv";
 dotenv.config({ path: "/var/www/ai-widget/server/.env" });
 
 import TelegramBot from "node-telegram-bot-api";
 
 import { ensureSchema } from "./lib/db.js";
 import { issueTelegramSecret } from "./lib/telegram.js";
 
 dotenv.config({ path: "/var/www/ai-widget/server/.env" });
 
 const token = process.env.TELEGRAM_BOT_TOKEN || "";
 
 if (!token) {
   console.error("[telegram-bot] TELEGRAM_BOT_TOKEN is not set in .env");
   process.exit(1);
 }
 
 
 const bot = new TelegramBot(token, { polling: true });
 
 await ensureSchema();
 
 async function sendNewSecret(chat) {
   const secret = await issueTelegramSecret({
     chatId: chat.id,
     username: chat?.username || null,
+    chatType: chat?.type || null,
   });
   const message =
     `Привет! Это бот уведомлений AI Widget.\n` +
     `Секретный код для привязки: ${secret}\n\n` +
     `Скопируйте его и вставьте в настройках проекта в админке, ` +
     `чтобы получать уведомления о новых чатах.`;
   await bot.sendMessage(chat.id, message);
 }
 
 bot.onText(/\/(start|code)/i, async (msg) => {
   try {
     await sendNewSecret(msg.chat);
   } catch (err) {
     console.error("[telegram-bot] failed to issue code", err?.message || err);
     await bot.sendMessage(msg.chat.id, "Не удалось выдать код. Попробуйте ещё раз позже.");
   }
 });
 
 bot.onText(/\/help/i, async (msg) => {
   const help =
     "Чтобы получать уведомления о новых диалогах:\n" +
     "1) Отправьте /code, чтобы получить секрет.\n" +
     "2) Откройте админку проекта и вставьте код в поле 'Telegram код'.";
   await bot.sendMessage(msg.chat.id, help);
 });
