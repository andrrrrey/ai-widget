diff --git a/server/src/index.js b/server/src/index.js
index fda83d53130e8ff38832222f7459e67129c79195..b8e8e5108485702fb9c7ea5b7be3da9e7ab61941 100644
--- a/server/src/index.js
+++ b/server/src/index.js
@@ -2,160 +2,168 @@ import express from "express";
 import cookieParser from "cookie-parser";
 import path from "path";
 import { fileURLToPath } from "url";
 import dotenv from "dotenv";
 
 import { ensureSchema, pool } from "./lib/db.js";
 import { requireAdmin, requireUser, loginHandler, logoutHandler, hashPassword } from "./lib/auth.js";
 import {
   createUser,
   listUsers,
   updateUserPassword,
   deleteUser,
   findUserByEmail,
   createProject,
   listProjects,
   getProject,
   updateProject,
   deleteProject,
   createChat,
   getChatById,
   listChats,
   listMessages,
   addMessage,
   setChatMode,
   touchChat,
+  countUserMessages,
 } from "./lib/store.js";
 import { widgetCors } from "./lib/widgetCors.js";
 import {
   fetchAssistantInstructions,
   runAssistantStream,
   syncOperatorToThread,
   updateAssistantInstructions,
 } from "./lib/openai.js";
 import { getChatDisplayName } from "./lib/chatNames.js";
-import { consumeTelegramSecret, notifyProjectAboutNewChat } from "./lib/telegram.js";
+import {
+  consumeTelegramSecret,
+  notifyProjectAboutFirstMessage,
+  notifyProjectAboutContacts,
+  extractContactInfo,
+} from "./lib/telegram.js";
 
 dotenv.config({ path: "/var/www/ai-widget/server/.env" });
 
 const NO_SOURCE_INSTRUCTION =
   "Не указывай в ответах источник документа, из которого взята информация.";
   
 const app = express();
 app.use(express.json({ limit: "2mb" }));
 app.use(express.urlencoded({ extended: true }));
 app.use(cookieParser());
 
 const __filename = fileURLToPath(import.meta.url);
 const __dirname = path.dirname(__filename);
 
 // Static: widget + admin
 app.use("/widget", express.static(path.join(__dirname, "../../widget")));
 app.use("/admin", express.static(path.join(__dirname, "../../web-admin")));
 
 app.get("/health", (req, res) => res.json({ ok: true, ts: Date.now() }));
 
 /**
  * WIDGET API (CORS allowlist per project)
  */
 app.options("/api/widget/:projectId/*", widgetCors);
 
 app.post("/api/widget/:projectId/chat/start", widgetCors, async (req, res) => {
   const { projectId } = req.params;
   const { visitorId } = req.body || {};
   const project = await getProject(projectId);
   if (!project) return res.status(404).json({ error: "project_not_found" });
   if (!project.openai_api_key) return res.status(400).json({ error: "openai_api_key_missing" });
 
   const chat = await createChat({
     projectId,
     visitorId: visitorId || null,
     openaiApiKey: project.openai_api_key,
   });
 
-  notifyProjectAboutNewChat(project, chat);
-
   res.json({ chatId: chat.id, mode: chat.mode });
 });
 
 app.get("/api/widget/:projectId/chat/:chatId/messages", widgetCors, async (req, res) => {
   const { projectId, chatId } = req.params;
   const chat = await getChatById(chatId);
   if (!chat || chat.project_id !== projectId) return res.status(404).json({ error: "chat_not_found" });
   const items = await listMessages(chatId);
   res.json({ items });
 });
 
 app.get("/api/widget/:projectId/chat/:chatId/stream", widgetCors, async (req, res) => {
   const { projectId, chatId } = req.params;
   const message = String(req.query.message || "").trim();
   if (!message) return res.status(400).json({ error: "empty_message" });
 
   const chat = await getChatById(chatId);
   if (!chat || chat.project_id !== projectId) return res.status(404).json({ error: "chat_not_found" });
+  const project = await getProject(projectId);
+  if (!project) return res.status(404).json({ error: "project_not_found" });
 
   // SSE headers
   res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
   res.setHeader("Cache-Control", "no-cache, no-transform");
   res.setHeader("Connection", "keep-alive");
   res.flushHeaders?.();
 
   const send = (event, data) => {
     res.write(`event: ${event}\n`);
     res.write(`data: ${JSON.stringify(data)}\n\n`);
   };
 
   const sanitizeCitations = (text) => text.replace(/【[^】]*】/g, "");
   let rawStream = "";
   let sentClean = "";
 
   const sendSanitizedToken = (token) => {
     rawStream += token || "";
     const cleaned = sanitizeCitations(rawStream);
     const delta = cleaned.slice(sentClean.length);
     if (delta) {
       send("token", { t: delta });
       sentClean = cleaned;
     }
   };
   
   try {
     await touchChat(chatId);
     await addMessage({ chatId, role: "user", content: message });
+    const userMessageCount = await countUserMessages(chatId);
+    if (userMessageCount === 1) {
+      await notifyProjectAboutFirstMessage(project, chat, message);
+    }
+    const contacts = extractContactInfo(message);
+    if (contacts.length > 0) {
+      await notifyProjectAboutContacts(project, chat, contacts, message);
+    }
 
     if (chat.mode === "human") {
       send("waiting_for_human", { chatId });
       send("done", { chatId });
       return res.end();
     }
 
-    const project = await getProject(projectId);
-    if (!project) {
-      send("error", { message: "project_not_found" });
-      send("done", { chatId });
-      return res.end();
-    }
     if (!project.assistant_id) {
       send("error", { message: "assistant_id is empty for this project" });
       send("done", { chatId });
       return res.end();
     }
     if (!project.openai_api_key) {
       send("error", { message: "openai_api_key is empty for this project" });
       send("done", { chatId });
       return res.end();
     }
 
     send("meta", { chatId, mode: "assistant" });
 
     const additionalInstructions = [project.instructions, NO_SOURCE_INSTRUCTION]
       .filter(Boolean)
       .join("\n\n");
       
     await runAssistantStream({
       apiKey: project.openai_api_key,
       threadId: chat.thread_id,
       assistantId: project.assistant_id,
       additionalInstructions,
       userMessage: message,
       onToken: (t) => sendSanitizedToken(t),
       onTool: (tool) => send("tool", tool),
diff --git a/server/src/lib/store.js b/server/src/lib/store.js
index 7e0fff8046ff83eb7c2dcb1baa3c8ad572b5bbef..953b1af9383cc2f93279165125e06f1b408f365d 100644
--- a/server/src/lib/store.js
+++ b/server/src/lib/store.js
@@ -132,34 +132,42 @@ export async function getChatById(chatId) {
 
 export async function listChats({ projectId, status = null, mode = null }) {
   const where = ["project_id=$1"];
   const params = [projectId];
   let i = 2;
 
   if (status) { where.push(`status=$${i++}`); params.push(status); }
   if (mode) { where.push(`mode=$${i++}`); params.push(mode); }
 
   const q = `SELECT * FROM chats WHERE ${where.join(" AND ")} ORDER BY updated_at DESC LIMIT 200`;
   return await sql.many(q, params);
 }
 
 export async function listMessages(chatId) {
   return await sql.many("SELECT * FROM messages WHERE chat_id=$1 ORDER BY created_at ASC", [chatId]);
 }
 
 export async function addMessage({ chatId, role, content }) {
   return await sql.one(
     `INSERT INTO messages (id, chat_id, role, content)
      VALUES ($1,$2,$3,$4) RETURNING *`,
     [uuidv4(), chatId, role, content]
   );
 }
 
+export async function countUserMessages(chatId) {
+  const row = await sql.one(
+    "SELECT COUNT(*)::int AS count FROM messages WHERE chat_id=$1 AND role='user'",
+    [chatId]
+  );
+  return row?.count ?? 0;
+}
+
 export async function setChatMode(chatId, mode) {
   const row = await sql.oneOrNone("UPDATE chats SET mode=$2, updated_at=NOW() WHERE id=$1 RETURNING *", [chatId, mode]);
   if (!row) throw new Error("chat_not_found");
   return row;
 }
 
 export async function touchChat(chatId) {
   await sql.exec("UPDATE chats SET updated_at=NOW(), last_seen_at=NOW() WHERE id=$1", [chatId]);
 }
diff --git a/server/src/lib/telegram.js b/server/src/lib/telegram.js
index fb225b6d17cbfd42f7fa69c172c45ee5dc4ab3d4..5870c038446570df6d09286147f26e4ec5b32ecd 100644
--- a/server/src/lib/telegram.js
+++ b/server/src/lib/telegram.js
@@ -44,39 +44,106 @@ export async function consumeTelegramSecret(secret) {
        SET used_at=NOW()
      WHERE secret=$1 AND used_at IS NULL
      RETURNING chat_id, username, created_at`,
     [secret]
   );
 }
 
 export async function sendTelegramMessage(chatId, text) {
   if (!TELEGRAM_TOKEN || !chatId || !text) return false;
 
   const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
   const body = { chat_id: chatId, text };
   const r = await fetch(url, {
     method: "POST",
     headers: { "Content-Type": "application/json" },
     body: JSON.stringify(body),
   });
 
   if (!r.ok) {
     const payload = await r.text();
     throw new Error(`telegram_error_${r.status}: ${payload}`);
   }
   return true;
 }
 
-export async function notifyProjectAboutNewChat(project, chat) {
+function formatProjectTitle(project) {
+  return project?.name ? `"${project.name}"` : "вашем сайте";
+}
+
+function formatChatId(chat) {
+  return chat?.id || "неизвестен";
+}
+
+function normalizeMatch(value) {
+  return String(value || "").trim();
+}
+
+export function extractContactInfo(text) {
+  if (!text) return [];
+  const candidates = [];
+  const emailMatches = text.match(/\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi) || [];
+  emailMatches.forEach((value) => candidates.push({ type: "email", value }));
+
+  const phoneMatches = text.match(/(\+?\d[\d\s().-]{6,}\d)/g) || [];
+  phoneMatches.forEach((value) => candidates.push({ type: "phone", value }));
+
+  const tgHandleMatches = text.match(/(?:^|\\s)@([a-zA-Z0-9_]{5,})/g) || [];
+  tgHandleMatches.forEach((value) => candidates.push({ type: "telegram", value }));
+
+  const tmeMatches = text.match(/t\\.me\\/([a-zA-Z0-9_]+)/gi) || [];
+  tmeMatches.forEach((value) => candidates.push({ type: "telegram", value }));
+
+  const waMatches = text.match(/wa\\.me\\/\\d+/gi) || [];
+  waMatches.forEach((value) => candidates.push({ type: "whatsapp", value }));
+
+  const tgLabelMatches = text.match(/(?:телеграм|telegram|tg)[:\\s]+([\\w@.+-]{3,})/gi) || [];
+  tgLabelMatches.forEach((value) => candidates.push({ type: "telegram", value }));
+
+  const waLabelMatches = text.match(/(?:whatsapp|ватсап|ватап)[:\\s]+([\\w@.+-]{3,})/gi) || [];
+  waLabelMatches.forEach((value) => candidates.push({ type: "whatsapp", value }));
+
+  const unique = new Map();
+  candidates.forEach((item) => {
+    const cleaned = normalizeMatch(item.value);
+    if (!cleaned) return;
+    const key = `${item.type}:${cleaned.toLowerCase()}`;
+    if (!unique.has(key)) {
+      unique.set(key, { type: item.type, value: cleaned });
+    }
+  });
+
+  return Array.from(unique.values());
+}
+
+export async function notifyProjectAboutFirstMessage(project, chat, messageText) {
+  if (!project?.telegram_chat_id || !isTelegramConfigured()) return;
+  const title = formatProjectTitle(project);
+  const message =
+    `На проекте ${title} получено первое сообщение от пользователя.\n` +
+    `ID чата: ${formatChatId(chat)}.\n` +
+    `Сообщение: ${String(messageText || "").trim().slice(0, 500) || "—"}`;
+
+  try {
+    await sendTelegramMessage(project.telegram_chat_id, message);
+  } catch (err) {
+    console.warn("telegram notify failed", err?.message || err);
+  }
+}
+
+export async function notifyProjectAboutContacts(project, chat, contacts, messageText) {
   if (!project?.telegram_chat_id || !isTelegramConfigured()) return;
-  const title = project?.name ? `"${project.name}"` : "вашем сайте";
+  if (!Array.isArray(contacts) || contacts.length === 0) return;
+  const title = formatProjectTitle(project);
+  const contactsLine = contacts.map((item) => item.value).join(", ");
   const message =
-    `На проекте ${title} открыт новый диалог.\n` +
-    `ID чата: ${chat?.id || "неизвестен"}.\n` +
-    `Скорее посмотрите в админке.`;
+    `На проекте ${title} пользователь оставил контакты.\n` +
+    `ID чата: ${formatChatId(chat)}.\n` +
+    `Контакты: ${contactsLine}\n` +
+    `Сообщение: ${String(messageText || "").trim().slice(0, 500) || "—"}`;
 
   try {
     await sendTelegramMessage(project.telegram_chat_id, message);
   } catch (err) {
     console.warn("telegram notify failed", err?.message || err);
   }
 }
